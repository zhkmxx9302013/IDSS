// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dss.proto
#ifndef GRPC_dss_2eproto__INCLUDED
#define GRPC_dss_2eproto__INCLUDED

#include "dss.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace buaa {
namespace dss {

// CLIPS Reasoning Service
class Reasoning final {
 public:
  static constexpr char const* service_full_name() {
    return "buaa.dss.Reasoning";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // @stub -param: facts -return: resoning results
    virtual ::grpc::Status GetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::buaa::facts::result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>> AsyncGetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>>(AsyncGetReasoningResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>> PrepareAsyncGetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>>(PrepareAsyncGetReasoningResultRaw(context, request, cq));
    }
    // @stub
    virtual ::grpc::Status StartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::buaa::dss::placeholder* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>> AsyncStartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>>(AsyncStartReasoningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>> PrepareAsyncStartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>>(PrepareAsyncStartReasoningRaw(context, request, cq));
    }
    // @stub -param:  -return:rule file list
    std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::rule_file_info>> GetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::rule_file_info>>(GetRuleFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>> AsyncGetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>>(AsyncGetRuleFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>> PrepareAsyncGetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>>(PrepareAsyncGetRuleFileRaw(context, request, cq));
    }
    // @stub -param: the rule files that wanna loaded  -return:null
    std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::rule_file_chk>> LoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::rule_file_chk>>(LoadRuleFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>> AsyncLoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>>(AsyncLoadRuleFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>> PrepareAsyncLoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>>(PrepareAsyncLoadRuleFileRaw(context, response, cq));
    }
    // @stub Get the list of slots according to the chosen rule files
    std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_list>> GetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_list>>(GetFactSlotsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>> AsyncGetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>>(AsyncGetFactSlotsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>> PrepareAsyncGetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>>(PrepareAsyncGetFactSlotsRaw(context, request, cq));
    }
    // @stub Set the list of slots that selected by user
    std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::fact_list>> SetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::fact_list>>(SetFactSlotsRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>> AsyncSetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>>(AsyncSetFactSlotsRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>> PrepareAsyncSetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>>(PrepareAsyncSetFactSlotsRaw(context, response, cq));
    }
    // @stub -param: the rule files that wanna loaded  -return:optional rule list
    std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_file_info>> GetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_file_info>>(GetFactFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>> AsyncGetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>>(AsyncGetFactFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>> PrepareAsyncGetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>>(PrepareAsyncGetFactFileRaw(context, request, cq));
    }
    // @stub -param: optional rule list  -return:null
    std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::fact_file_chk>> LoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::fact_file_chk>>(LoadFactFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>> AsyncLoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>>(AsyncLoadFactFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>> PrepareAsyncLoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>>(PrepareAsyncLoadFactFileRaw(context, response, cq));
    }
    // @stub Get the Slot list that selected before
    std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_list>> GetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_list>>(GetSelectedSlotsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>> AsyncGetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>>(AsyncGetSelectedSlotsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>> PrepareAsyncGetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>>(PrepareAsyncGetSelectedSlotsRaw(context, request, cq));
    }
    // @stub Get the optional variables from the facts file
    std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_var>> GetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::buaa::file::fact_var>>(GetVariableListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>> AsyncGetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>>(AsyncGetVariableListRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>> PrepareAsyncGetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>>(PrepareAsyncGetVariableListRaw(context, request, cq));
    }
    // @stub Set the <slot:variable> kv mapping
    std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::mapper>> SetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::buaa::file::mapper>>(SetMappingListRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>> AsyncSetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>>(AsyncSetMappingListRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>> PrepareAsyncSetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>>(PrepareAsyncSetMappingListRaw(context, response, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>* AsyncGetReasoningResultRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::buaa::facts::result>* PrepareAsyncGetReasoningResultRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>* AsyncStartReasoningRaw(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::buaa::dss::placeholder>* PrepareAsyncStartReasoningRaw(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::buaa::file::rule_file_info>* GetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>* AsyncGetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::rule_file_info>* PrepareAsyncGetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::buaa::file::rule_file_chk>* LoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>* AsyncLoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::rule_file_chk>* PrepareAsyncLoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::buaa::file::fact_list>* GetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>* AsyncGetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>* PrepareAsyncGetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::buaa::file::fact_list>* SetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>* AsyncSetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_list>* PrepareAsyncSetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::buaa::file::fact_file_info>* GetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>* AsyncGetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_file_info>* PrepareAsyncGetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::buaa::file::fact_file_chk>* LoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>* AsyncLoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::fact_file_chk>* PrepareAsyncLoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::buaa::file::fact_list>* GetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>* AsyncGetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_list>* PrepareAsyncGetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::buaa::file::fact_var>* GetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>* AsyncGetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::buaa::file::fact_var>* PrepareAsyncGetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::buaa::file::mapper>* SetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>* AsyncSetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::buaa::file::mapper>* PrepareAsyncSetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::buaa::facts::result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>> AsyncGetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>>(AsyncGetReasoningResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>> PrepareAsyncGetReasoningResult(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>>(PrepareAsyncGetReasoningResultRaw(context, request, cq));
    }
    ::grpc::Status StartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::buaa::dss::placeholder* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>> AsyncStartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>>(AsyncStartReasoningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>> PrepareAsyncStartReasoning(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>>(PrepareAsyncStartReasoningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::buaa::file::rule_file_info>> GetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::buaa::file::rule_file_info>>(GetRuleFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>> AsyncGetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>>(AsyncGetRuleFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>> PrepareAsyncGetRuleFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>>(PrepareAsyncGetRuleFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::rule_file_chk>> LoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::rule_file_chk>>(LoadRuleFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>> AsyncLoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>>(AsyncLoadRuleFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>> PrepareAsyncLoadRuleFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>>(PrepareAsyncLoadRuleFileRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_list>> GetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_list>>(GetFactSlotsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>> AsyncGetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>>(AsyncGetFactSlotsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>> PrepareAsyncGetFactSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>>(PrepareAsyncGetFactSlotsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::fact_list>> SetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::fact_list>>(SetFactSlotsRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>> AsyncSetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>>(AsyncSetFactSlotsRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>> PrepareAsyncSetFactSlots(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>>(PrepareAsyncSetFactSlotsRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_file_info>> GetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_file_info>>(GetFactFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>> AsyncGetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>>(AsyncGetFactFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>> PrepareAsyncGetFactFile(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>>(PrepareAsyncGetFactFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::fact_file_chk>> LoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::fact_file_chk>>(LoadFactFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>> AsyncLoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>>(AsyncLoadFactFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>> PrepareAsyncLoadFactFile(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>>(PrepareAsyncLoadFactFileRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_list>> GetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_list>>(GetSelectedSlotsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>> AsyncGetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>>(AsyncGetSelectedSlotsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>> PrepareAsyncGetSelectedSlots(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_list>>(PrepareAsyncGetSelectedSlotsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_var>> GetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::buaa::file::fact_var>>(GetVariableListRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_var>> AsyncGetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_var>>(AsyncGetVariableListRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_var>> PrepareAsyncGetVariableList(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::buaa::file::fact_var>>(PrepareAsyncGetVariableListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::mapper>> SetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::buaa::file::mapper>>(SetMappingListRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::mapper>> AsyncSetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::mapper>>(AsyncSetMappingListRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::mapper>> PrepareAsyncSetMappingList(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::buaa::file::mapper>>(PrepareAsyncSetMappingListRaw(context, response, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>* AsyncGetReasoningResultRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::buaa::facts::result>* PrepareAsyncGetReasoningResultRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>* AsyncStartReasoningRaw(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::buaa::dss::placeholder>* PrepareAsyncStartReasoningRaw(::grpc::ClientContext* context, const ::buaa::facts::sim_start& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::buaa::file::rule_file_info>* GetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) override;
    ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>* AsyncGetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::buaa::file::rule_file_info>* PrepareAsyncGetRuleFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::buaa::file::rule_file_chk>* LoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>* AsyncLoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::rule_file_chk>* PrepareAsyncLoadRuleFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::buaa::file::fact_list>* GetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_list>* AsyncGetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_list>* PrepareAsyncGetFactSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::buaa::file::fact_list>* SetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>* AsyncSetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::fact_list>* PrepareAsyncSetFactSlotsRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::buaa::file::fact_file_info>* GetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>* AsyncGetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_file_info>* PrepareAsyncGetFactFileRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::buaa::file::fact_file_chk>* LoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>* AsyncLoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::fact_file_chk>* PrepareAsyncLoadFactFileRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::buaa::file::fact_list>* GetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_list>* AsyncGetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_list>* PrepareAsyncGetSelectedSlotsRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::buaa::file::fact_var>* GetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_var>* AsyncGetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::buaa::file::fact_var>* PrepareAsyncGetVariableListRaw(::grpc::ClientContext* context, const ::buaa::dss::placeholder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::buaa::file::mapper>* SetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::mapper>* AsyncSetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::buaa::file::mapper>* PrepareAsyncSetMappingListRaw(::grpc::ClientContext* context, ::buaa::dss::placeholder* response, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetReasoningResult_;
    const ::grpc::internal::RpcMethod rpcmethod_StartReasoning_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRuleFile_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadRuleFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFactSlots_;
    const ::grpc::internal::RpcMethod rpcmethod_SetFactSlots_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFactFile_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadFactFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSelectedSlots_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVariableList_;
    const ::grpc::internal::RpcMethod rpcmethod_SetMappingList_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // @stub -param: facts -return: resoning results
    virtual ::grpc::Status GetReasoningResult(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::buaa::facts::result* response);
    // @stub
    virtual ::grpc::Status StartReasoning(::grpc::ServerContext* context, const ::buaa::facts::sim_start* request, ::buaa::dss::placeholder* response);
    // @stub -param:  -return:rule file list
    virtual ::grpc::Status GetRuleFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::rule_file_info>* writer);
    // @stub -param: the rule files that wanna loaded  -return:null
    virtual ::grpc::Status LoadRuleFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::rule_file_chk>* reader, ::buaa::dss::placeholder* response);
    // @stub Get the list of slots according to the chosen rule files
    virtual ::grpc::Status GetFactSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer);
    // @stub Set the list of slots that selected by user
    virtual ::grpc::Status SetFactSlots(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_list>* reader, ::buaa::dss::placeholder* response);
    // @stub -param: the rule files that wanna loaded  -return:optional rule list
    virtual ::grpc::Status GetFactFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_file_info>* writer);
    // @stub -param: optional rule list  -return:null
    virtual ::grpc::Status LoadFactFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_file_chk>* reader, ::buaa::dss::placeholder* response);
    // @stub Get the Slot list that selected before
    virtual ::grpc::Status GetSelectedSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer);
    // @stub Get the optional variables from the facts file
    virtual ::grpc::Status GetVariableList(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_var>* writer);
    // @stub Set the <slot:variable> kv mapping
    virtual ::grpc::Status SetMappingList(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::mapper>* reader, ::buaa::dss::placeholder* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetReasoningResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetReasoningResult() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetReasoningResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReasoningResult(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::buaa::facts::result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetReasoningResult(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncResponseWriter< ::buaa::facts::result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartReasoning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartReasoning() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StartReasoning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartReasoning(::grpc::ServerContext* context, const ::buaa::facts::sim_start* request, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartReasoning(::grpc::ServerContext* context, ::buaa::facts::sim_start* request, ::grpc::ServerAsyncResponseWriter< ::buaa::dss::placeholder>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRuleFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetRuleFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRuleFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRuleFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::rule_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRuleFile(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncWriter< ::buaa::file::rule_file_info>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadRuleFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LoadRuleFile() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_LoadRuleFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadRuleFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::rule_file_chk>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadRuleFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::buaa::dss::placeholder, ::buaa::file::rule_file_chk>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(3, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFactSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetFactSlots() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetFactSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFactSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFactSlots(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncWriter< ::buaa::file::fact_list>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetFactSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetFactSlots() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetFactSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFactSlots(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_list>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetFactSlots(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::buaa::dss::placeholder, ::buaa::file::fact_list>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(5, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFactFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetFactFile() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetFactFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFactFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFactFile(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncWriter< ::buaa::file::fact_file_info>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadFactFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LoadFactFile() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_LoadFactFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadFactFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_file_chk>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadFactFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::buaa::dss::placeholder, ::buaa::file::fact_file_chk>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(7, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSelectedSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSelectedSlots() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetSelectedSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSelectedSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSelectedSlots(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncWriter< ::buaa::file::fact_list>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVariableList() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_var>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableList(::grpc::ServerContext* context, ::buaa::dss::placeholder* request, ::grpc::ServerAsyncWriter< ::buaa::file::fact_var>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetMappingList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetMappingList() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_SetMappingList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMappingList(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::mapper>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetMappingList(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::buaa::dss::placeholder, ::buaa::file::mapper>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(10, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetReasoningResult<WithAsyncMethod_StartReasoning<WithAsyncMethod_GetRuleFile<WithAsyncMethod_LoadRuleFile<WithAsyncMethod_GetFactSlots<WithAsyncMethod_SetFactSlots<WithAsyncMethod_GetFactFile<WithAsyncMethod_LoadFactFile<WithAsyncMethod_GetSelectedSlots<WithAsyncMethod_GetVariableList<WithAsyncMethod_SetMappingList<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_GetReasoningResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetReasoningResult() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetReasoningResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetReasoningResult(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::buaa::facts::result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartReasoning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartReasoning() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StartReasoning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartReasoning(::grpc::ServerContext* context, const ::buaa::facts::sim_start* request, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRuleFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetRuleFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRuleFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRuleFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::rule_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadRuleFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LoadRuleFile() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_LoadRuleFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadRuleFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::rule_file_chk>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFactSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetFactSlots() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetFactSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFactSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetFactSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetFactSlots() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetFactSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetFactSlots(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_list>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFactFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetFactFile() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetFactFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFactFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadFactFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LoadFactFile() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_LoadFactFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadFactFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::fact_file_chk>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSelectedSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSelectedSlots() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetSelectedSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSelectedSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVariableList() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_var>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetMappingList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetMappingList() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_SetMappingList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetMappingList(::grpc::ServerContext* context, ::grpc::ServerReader< ::buaa::file::mapper>* reader, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetReasoningResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetReasoningResult() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::buaa::dss::placeholder, ::buaa::facts::result>(std::bind(&WithStreamedUnaryMethod_GetReasoningResult<BaseClass>::StreamedGetReasoningResult, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetReasoningResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetReasoningResult(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::buaa::facts::result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetReasoningResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::buaa::dss::placeholder,::buaa::facts::result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartReasoning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartReasoning() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::buaa::facts::sim_start, ::buaa::dss::placeholder>(std::bind(&WithStreamedUnaryMethod_StartReasoning<BaseClass>::StreamedStartReasoning, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartReasoning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartReasoning(::grpc::ServerContext* context, const ::buaa::facts::sim_start* request, ::buaa::dss::placeholder* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartReasoning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::buaa::facts::sim_start,::buaa::dss::placeholder>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetReasoningResult<WithStreamedUnaryMethod_StartReasoning<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetRuleFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetRuleFile() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::buaa::dss::placeholder, ::buaa::file::rule_file_info>(std::bind(&WithSplitStreamingMethod_GetRuleFile<BaseClass>::StreamedGetRuleFile, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetRuleFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRuleFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::rule_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetRuleFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::buaa::dss::placeholder,::buaa::file::rule_file_info>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetFactSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetFactSlots() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler< ::buaa::dss::placeholder, ::buaa::file::fact_list>(std::bind(&WithSplitStreamingMethod_GetFactSlots<BaseClass>::StreamedGetFactSlots, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetFactSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFactSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetFactSlots(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::buaa::dss::placeholder,::buaa::file::fact_list>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetFactFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetFactFile() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler< ::buaa::dss::placeholder, ::buaa::file::fact_file_info>(std::bind(&WithSplitStreamingMethod_GetFactFile<BaseClass>::StreamedGetFactFile, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetFactFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFactFile(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_file_info>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetFactFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::buaa::dss::placeholder,::buaa::file::fact_file_info>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetSelectedSlots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetSelectedSlots() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler< ::buaa::dss::placeholder, ::buaa::file::fact_list>(std::bind(&WithSplitStreamingMethod_GetSelectedSlots<BaseClass>::StreamedGetSelectedSlots, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetSelectedSlots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSelectedSlots(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_list>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetSelectedSlots(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::buaa::dss::placeholder,::buaa::file::fact_list>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetVariableList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_GetVariableList() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler< ::buaa::dss::placeholder, ::buaa::file::fact_var>(std::bind(&WithSplitStreamingMethod_GetVariableList<BaseClass>::StreamedGetVariableList, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_GetVariableList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVariableList(::grpc::ServerContext* context, const ::buaa::dss::placeholder* request, ::grpc::ServerWriter< ::buaa::file::fact_var>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetVariableList(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::buaa::dss::placeholder,::buaa::file::fact_var>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetRuleFile<WithSplitStreamingMethod_GetFactSlots<WithSplitStreamingMethod_GetFactFile<WithSplitStreamingMethod_GetSelectedSlots<WithSplitStreamingMethod_GetVariableList<Service > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetReasoningResult<WithStreamedUnaryMethod_StartReasoning<WithSplitStreamingMethod_GetRuleFile<WithSplitStreamingMethod_GetFactSlots<WithSplitStreamingMethod_GetFactFile<WithSplitStreamingMethod_GetSelectedSlots<WithSplitStreamingMethod_GetVariableList<Service > > > > > > > StreamedService;
};

}  // namespace dss
}  // namespace buaa


#endif  // GRPC_dss_2eproto__INCLUDED
